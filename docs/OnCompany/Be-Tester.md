日志问题,
不同函数日志上下文, 有的以 service_id 为过滤条件, 有的能从 mc 过滤到, 有的只能从函数 name 过滤, 增加查询难度
比如 spm send_task 最终要 handle 时已经跨文件了, 最终是否处理需要 handle 时打印, 而其没有加

从哪里推导出问题:
1.最终现象不为期望, 这是最简单的方式, 可是一般需要佐证, 帮助判断条件是正常的, 以降低误判概率, 自己也能再反省(比如提供处理时日志, 配置的图片, 数据等)
2.找出具体日志, 进行分辨后交给开发. 这里有个问题: (期间跨服务器短时间内有多个操作不好找日志) 推荐之后开发写代码检查加上对日志纠察, 甚至给每一次处理传递 唯一 ID, 方便快速找到附近日志

suggestion2 :
获取代码
python 页面的, 代码权限, 现在只有一个可执行文件以及配置
SPM 部分因为 openresty 本身就暴露了代码
而core 等网元代码太复杂, 这方面还是由开发查更快

原因:
1.方便确认逻辑. 为什么不直接找开发: 简单的一些设计可能自己打开文件看下比找开发问更快
更便于分析问题





掉进了增量设计测试的漩涡, 为了测试而测试的感觉, 项目结束后马不停蹄下一个, 反思还要抽出时间, 比如抽出时间想想这个 
汇报





测试用例： 从一份设计文档中， 以及开发讲述中扣出测试点来， 再进化为用例
扣出测试点依赖一部分逻辑思考能力和部分对系统的熟悉，我认为在这一部分思考能力更重要，对系统的熟悉助力你判断着是否属于一个测试点
而对于用例书写则更多依赖于对系统的熟悉，约越熟悉就越全面，越能自主判断测试点重要性，比如：根据之前经验这个地方有过错误， 需要着重测试
还有，用例框架也较为重要。关于用例复用: 个人认为还是要看类型， 纯增量的修改可能不太有复用机会， 而如果是重构优化部分内容则会用到一些，我就会基于原来的一份进行增删用例



收集问题: 
大部分问题都不是结论直接发到群里的, 而是开发开完后直接解决, 即 没有公布答案, 正好方便猜想, 完成后再询问, 即使不记得也能提供思路
很大一部分 core 都没收集, 太琐碎, 也没有足够时间

之前收集并分析过, 最近又回顾, 最重要的, 增加测试对于线上问题参与度

- 1.由测试接手有哪些难度, 对于现状进行分析
  对于现状进行分析, 即 如果线上出现问题, 运维直接找开发协助解决, 而不是测试.
  1.开发时间周期短, 测试时间长, 因此开发有更长的处理问题时长(虽然有解决 bug), 造成了依赖
  2.对问题依旧不够熟悉, 对全局理解度不够, 对于线上数据的了解

  分工方面, 更熟悉系统 比如: "url 错了 看下". 能直接判断谁的问题.
  开发长期跟进线上, 而非测试,比如: 二级缓存
  对于线上数据的了解, 比如: 手机数据等
  因此

- 2.由测试接手如何实施 
  有做 线上问题记录处理 尝试了解问题类型, 归类问题, 遇到新问题便于自身分析, 因为从来到现在, 很少去解决线上问题, 导致了解度不高, (虽然内网有解决) 参考定位问题方式思路
  示例: 回看页面的问题和开发一起定位了

1.像 bug 一样, 运维提给测试, 测试确认后转给开发, 协同跟进, 而像 core 问题一类的可以直接给开发, 
就是创建一个新的提问题方式, 如果依旧使用之前的方式可能短时间强调后有帮助, 但时间长了又恢复了, 可能说很多次还没有改善这一个结局.



问题收集, 突然想起, 任务可能没那么简单, 大部分问题都不是结论直接发到群里的, 而是开发开完后直接解决, 即 没有公布答案, 正好方便猜想, 完成后再询问, 即使不记得也能提供思路







